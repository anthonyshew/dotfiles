/**
 * OpenCode Swarm Plugin Wrapper
 *
 * This is a thin wrapper that shells out to the `swarm` CLI for all tool execution.
 * Generated by: swarm setup
 *
 * The plugin only depends on @opencode-ai/plugin (provided by OpenCode).
 * All tool logic lives in the npm package - this just bridges to it.
 *
 * Environment variables:
 * - OPENCODE_SESSION_ID: Passed to CLI for session state persistence
 * - OPENCODE_MESSAGE_ID: Passed to CLI for context
 * - OPENCODE_AGENT: Passed to CLI for context
 * - SWARM_PROJECT_DIR: Project directory (critical for database path)
 */
import type { Plugin, PluginInput, Hooks } from "@opencode-ai/plugin";
import { tool } from "@opencode-ai/plugin";
import { spawn } from "child_process";

const SWARM_CLI = "swarm";

// Module-level project directory - set during plugin initialization
// This is CRITICAL: without it, the CLI uses process.cwd() which may be wrong
let projectDirectory: string = process.cwd();

// =============================================================================
// CLI Execution Helper
// =============================================================================

/**
 * Execute a swarm tool via CLI
 *
 * Spawns `swarm tool <name> --json '<args>'` and returns the result.
 * Passes session context via environment variables.
 * 
 * IMPORTANT: Runs in projectDirectory (set by OpenCode) not process.cwd()
 */
async function execTool(
  name: string,
  args: Record<string, unknown>,
  ctx: { sessionID: string; messageID: string; agent: string },
): Promise<string> {
  return new Promise((resolve, reject) => {
    const hasArgs = Object.keys(args).length > 0;
    const cliArgs = hasArgs
      ? ["tool", name, "--json", JSON.stringify(args)]
      : ["tool", name];

    const proc = spawn(SWARM_CLI, cliArgs, {
      cwd: projectDirectory, // Run in project directory, not plugin directory
      stdio: ["ignore", "pipe", "pipe"],
      env: {
        ...process.env,
        OPENCODE_SESSION_ID: ctx.sessionID,
        OPENCODE_MESSAGE_ID: ctx.messageID,
        OPENCODE_AGENT: ctx.agent,
        SWARM_PROJECT_DIR: projectDirectory, // Also pass as env var
      },
    });

    let stdout = "";
    let stderr = "";

    proc.stdout.on("data", (data) => {
      stdout += data;
    });
    proc.stderr.on("data", (data) => {
      stderr += data;
    });

    proc.on("close", (code) => {
      if (code === 0) {
        // Success - return the JSON output
        try {
          const result = JSON.parse(stdout);
          if (result.success && result.data !== undefined) {
            // Unwrap the data for cleaner tool output
            resolve(
              typeof result.data === "string"
                ? result.data
                : JSON.stringify(result.data, null, 2),
            );
          } else if (!result.success && result.error) {
            // Tool returned an error in JSON format
            // Handle both string errors and object errors with .message
            const errorMsg = typeof result.error === "string" 
              ? result.error 
              : (result.error.message || "Tool execution failed");
            reject(new Error(errorMsg));
          } else {
            resolve(stdout);
          }
        } catch {
          resolve(stdout);
        }
      } else if (code === 2) {
        reject(new Error(`Unknown tool: ${name}`));
      } else if (code === 3) {
        reject(new Error(`Invalid JSON args: ${stderr}`));
      } else {
        // Tool returned error
        try {
          const result = JSON.parse(stdout);
          if (!result.success && result.error) {
            // Handle both string errors and object errors with .message
            const errorMsg = typeof result.error === "string"
              ? result.error
              : (result.error.message || `Tool failed with code ${code}`);
            reject(new Error(errorMsg));
          } else {
            reject(
              new Error(stderr || stdout || `Tool failed with code ${code}`),
            );
          }
        } catch {
          reject(
            new Error(stderr || stdout || `Tool failed with code ${code}`),
          );
        }
      }
    });

    proc.on("error", (err) => {
      if ((err as NodeJS.ErrnoException).code === "ENOENT") {
        reject(
          new Error(
            `swarm CLI not found. Install with: npm install -g opencode-swarm-plugin`,
          ),
        );
      } else {
        reject(err);
      }
    });
  });
}

// =============================================================================
// Beads Tools
// =============================================================================

const hive_create = tool({
  description: "Create a new bead with type-safe validation",
  args: {
    title: tool.schema.string().describe("Bead title"),
    type: tool.schema
      .enum(["bug", "feature", "task", "epic", "chore"])
      .optional()
      .describe("Issue type (default: task)"),
    priority: tool.schema
      .number()
      .min(0)
      .max(3)
      .optional()
      .describe("Priority 0-3 (default: 2)"),
    description: tool.schema.string().optional().describe("Bead description"),
    parent_id: tool.schema
      .string()
      .optional()
      .describe("Parent bead ID for epic children"),
  },
  execute: (args, ctx) => execTool("hive_create", args, ctx),
});

const hive_create_epic = tool({
  description: "Create epic with subtasks in one atomic operation",
  args: {
    epic_title: tool.schema.string().describe("Epic title"),
    epic_description: tool.schema
      .string()
      .optional()
      .describe("Epic description"),
    subtasks: tool.schema
      .array(
        tool.schema.object({
          title: tool.schema.string(),
          priority: tool.schema.number().min(0).max(3).optional(),
          files: tool.schema.array(tool.schema.string()).optional(),
        }),
      )
      .describe("Subtasks to create under the epic"),
  },
  execute: (args, ctx) => execTool("hive_create_epic", args, ctx),
});

const hive_query = tool({
  description: "Query beads with filters (replaces bd list, bd ready, bd wip)",
  args: {
    status: tool.schema
      .enum(["open", "in_progress", "blocked", "closed"])
      .optional()
      .describe("Filter by status"),
    type: tool.schema
      .enum(["bug", "feature", "task", "epic", "chore"])
      .optional()
      .describe("Filter by type"),
    ready: tool.schema
      .boolean()
      .optional()
      .describe("Only show unblocked beads"),
    limit: tool.schema
      .number()
      .optional()
      .describe("Max results (default: 20)"),
  },
  execute: (args, ctx) => execTool("hive_query", args, ctx),
});

const hive_update = tool({
  description: "Update bead status/description",
  args: {
    id: tool.schema.string().describe("Cell ID"),
    status: tool.schema
      .enum(["open", "in_progress", "blocked", "closed"])
      .optional()
      .describe("New status"),
    description: tool.schema.string().optional().describe("New description"),
    priority: tool.schema
      .number()
      .min(0)
      .max(3)
      .optional()
      .describe("New priority"),
  },
  execute: (args, ctx) => execTool("hive_update", args, ctx),
});

const hive_close = tool({
  description: "Close a bead with reason",
  args: {
    id: tool.schema.string().describe("Cell ID"),
    reason: tool.schema.string().describe("Completion reason"),
  },
  execute: (args, ctx) => execTool("hive_close", args, ctx),
});

const hive_start = tool({
  description: "Mark a bead as in-progress",
  args: {
    id: tool.schema.string().describe("Cell ID"),
  },
  execute: (args, ctx) => execTool("hive_start", args, ctx),
});

const hive_ready = tool({
  description: "Get the next ready bead (unblocked, highest priority)",
  args: {},
  execute: (args, ctx) => execTool("hive_ready", args, ctx),
});

const hive_sync = tool({
  description: "Sync beads to git and push (MANDATORY at session end)",
  args: {
    auto_pull: tool.schema.boolean().optional().describe("Pull before sync"),
  },
  execute: (args, ctx) => execTool("hive_sync", args, ctx),
});

const beads_link_thread = tool({
  description: "Add metadata linking bead to Agent Mail thread",
  args: {
    bead_id: tool.schema.string().describe("Cell ID"),
    thread_id: tool.schema.string().describe("Agent Mail thread ID"),
  },
  execute: (args, ctx) => execTool("beads_link_thread", args, ctx),
});

// =============================================================================
// Swarm Mail Tools (Embedded)
// =============================================================================

const swarmmail_init = tool({
  description: "Initialize Swarm Mail session (REQUIRED FIRST)",
  args: {
    project_path: tool.schema.string().describe("Absolute path to the project"),
    agent_name: tool.schema.string().optional().describe("Custom agent name"),
    task_description: tool.schema
      .string()
      .optional()
      .describe("Task description"),
  },
  execute: (args, ctx) => execTool("swarmmail_init", args, ctx),
});

const swarmmail_send = tool({
  description: "Send message to other agents via Swarm Mail",
  args: {
    to: tool.schema
      .array(tool.schema.string())
      .describe("Recipient agent names"),
    subject: tool.schema.string().describe("Message subject"),
    body: tool.schema.string().describe("Message body"),
    thread_id: tool.schema
      .string()
      .optional()
      .describe("Thread ID for grouping"),
    importance: tool.schema
      .enum(["low", "normal", "high", "urgent"])
      .optional()
      .describe("Message importance"),
    ack_required: tool.schema
      .boolean()
      .optional()
      .describe("Require acknowledgment"),
  },
  execute: (args, ctx) => execTool("swarmmail_send", args, ctx),
});

const swarmmail_inbox = tool({
  description: "Fetch inbox (CONTEXT-SAFE: bodies excluded, max 5 messages)",
  args: {
    limit: tool.schema
      .number()
      .max(5)
      .optional()
      .describe("Max messages (max 5)"),
    urgent_only: tool.schema
      .boolean()
      .optional()
      .describe("Only urgent messages"),
  },
  execute: (args, ctx) => execTool("swarmmail_inbox", args, ctx),
});

const swarmmail_read_message = tool({
  description: "Fetch ONE message body by ID",
  args: {
    message_id: tool.schema.number().describe("Message ID"),
  },
  execute: (args, ctx) => execTool("swarmmail_read_message", args, ctx),
});

const swarmmail_reserve = tool({
  description: "Reserve file paths for exclusive editing",
  args: {
    paths: tool.schema
      .array(tool.schema.string())
      .describe("File paths/patterns"),
    ttl_seconds: tool.schema.number().optional().describe("Reservation TTL"),
    exclusive: tool.schema.boolean().optional().describe("Exclusive lock"),
    reason: tool.schema.string().optional().describe("Reservation reason"),
  },
  execute: (args, ctx) => execTool("swarmmail_reserve", args, ctx),
});

const swarmmail_release = tool({
  description: "Release file reservations",
  args: {
    paths: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Paths to release"),
    reservation_ids: tool.schema
      .array(tool.schema.number())
      .optional()
      .describe("Reservation IDs"),
  },
  execute: (args, ctx) => execTool("swarmmail_release", args, ctx),
});

const swarmmail_ack = tool({
  description: "Acknowledge a message",
  args: {
    message_id: tool.schema.number().describe("Message ID"),
  },
  execute: (args, ctx) => execTool("swarmmail_ack", args, ctx),
});

const swarmmail_health = tool({
  description: "Check Swarm Mail database health",
  args: {},
  execute: (args, ctx) => execTool("swarmmail_health", args, ctx),
});

// =============================================================================
// Structured Tools
// =============================================================================

const structured_extract_json = tool({
  description: "Extract JSON from markdown/text response",
  args: {
    text: tool.schema.string().describe("Text containing JSON"),
  },
  execute: (args, ctx) => execTool("structured_extract_json", args, ctx),
});

const structured_validate = tool({
  description: "Validate agent response against a schema",
  args: {
    response: tool.schema.string().describe("Agent response to validate"),
    schema_name: tool.schema
      .enum(["evaluation", "task_decomposition", "cell_tree"])
      .describe("Schema to validate against"),
    max_retries: tool.schema
      .number()
      .min(1)
      .max(5)
      .optional()
      .describe("Max retries"),
  },
  execute: (args, ctx) => execTool("structured_validate", args, ctx),
});

const structured_parse_evaluation = tool({
  description: "Parse and validate evaluation response",
  args: {
    response: tool.schema.string().describe("Agent response"),
  },
  execute: (args, ctx) => execTool("structured_parse_evaluation", args, ctx),
});

const structured_parse_decomposition = tool({
  description: "Parse and validate task decomposition response",
  args: {
    response: tool.schema.string().describe("Agent response"),
  },
  execute: (args, ctx) => execTool("structured_parse_decomposition", args, ctx),
});

const structured_parse_cell_tree = tool({
  description: "Parse and validate bead tree response",
  args: {
    response: tool.schema.string().describe("Agent response"),
  },
  execute: (args, ctx) => execTool("structured_parse_cell_tree", args, ctx),
});

// =============================================================================
// Swarm Tools
// =============================================================================

const swarm_init = tool({
  description: "Initialize swarm session and check tool availability",
  args: {
    project_path: tool.schema.string().optional().describe("Project path"),
    isolation: tool.schema
      .enum(["worktree", "reservation"])
      .optional()
      .describe(
        "Isolation mode: 'worktree' for git worktree isolation, 'reservation' for file reservations (default)",
      ),
  },
  execute: (args, ctx) => execTool("swarm_init", args, ctx),
});

const swarm_select_strategy = tool({
  description: "Analyze task and recommend decomposition strategy",
  args: {
    task: tool.schema.string().min(1).describe("Task to analyze"),
    codebase_context: tool.schema
      .string()
      .optional()
      .describe("Codebase context"),
  },
  execute: (args, ctx) => execTool("swarm_select_strategy", args, ctx),
});

const swarm_plan_prompt = tool({
  description: "Generate strategy-specific decomposition prompt",
  args: {
    task: tool.schema.string().min(1).describe("Task to decompose"),
    strategy: tool.schema
      .enum(["file-based", "feature-based", "risk-based", "auto"])
      .optional()
      .describe("Decomposition strategy"),
    max_subtasks: tool.schema
      .number()
      .int()
      .min(2)
      .max(10)
      .optional()
      .describe("Max subtasks"),
    context: tool.schema.string().optional().describe("Additional context"),
    query_cass: tool.schema
      .boolean()
      .optional()
      .describe("Query CASS for similar tasks"),
    cass_limit: tool.schema
      .number()
      .int()
      .min(1)
      .max(10)
      .optional()
      .describe("CASS limit"),
  },
  execute: (args, ctx) => execTool("swarm_plan_prompt", args, ctx),
});

const swarm_decompose = tool({
  description: "Generate decomposition prompt for breaking task into subtasks",
  args: {
    task: tool.schema.string().min(1).describe("Task to decompose"),
    max_subtasks: tool.schema
      .number()
      .int()
      .min(2)
      .max(10)
      .optional()
      .describe("Max subtasks"),
    context: tool.schema.string().optional().describe("Additional context"),
    query_cass: tool.schema.boolean().optional().describe("Query CASS"),
    cass_limit: tool.schema
      .number()
      .int()
      .min(1)
      .max(10)
      .optional()
      .describe("CASS limit"),
  },
  execute: (args, ctx) => execTool("swarm_decompose", args, ctx),
});

const swarm_validate_decomposition = tool({
  description: "Validate a decomposition response against CellTreeSchema",
  args: {
    response: tool.schema.string().describe("Decomposition response"),
  },
  execute: (args, ctx) => execTool("swarm_validate_decomposition", args, ctx),
});

const swarm_status = tool({
  description: "Get status of a swarm by epic ID",
  args: {
    epic_id: tool.schema.string().describe("Epic bead ID"),
    project_key: tool.schema.string().describe("Project key"),
  },
  execute: (args, ctx) => execTool("swarm_status", args, ctx),
});

const swarm_progress = tool({
  description: "Report progress on a subtask to coordinator",
  args: {
    project_key: tool.schema.string().describe("Project key"),
    agent_name: tool.schema.string().describe("Agent name"),
    bead_id: tool.schema.string().describe("Cell ID"),
    status: tool.schema
      .enum(["in_progress", "blocked", "completed", "failed"])
      .describe("Status"),
    message: tool.schema.string().optional().describe("Progress message"),
    progress_percent: tool.schema
      .number()
      .min(0)
      .max(100)
      .optional()
      .describe("Progress %"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files modified"),
  },
  execute: (args, ctx) => execTool("swarm_progress", args, ctx),
});

const swarm_complete = tool({
  description:
    "Mark subtask complete with Verification Gate. Runs UBS scan, typecheck, and tests before allowing completion.",
  args: {
    project_key: tool.schema.string().describe("Project key"),
    agent_name: tool.schema.string().describe("Agent name"),
    bead_id: tool.schema.string().describe("Cell ID"),
    summary: tool.schema.string().describe("Completion summary"),
    evaluation: tool.schema.string().optional().describe("Self-evaluation JSON"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files modified - will be verified"),
    skip_ubs_scan: tool.schema.boolean().optional().describe("Skip UBS scan"),
    skip_verification: tool.schema
      .boolean()
      .optional()
      .describe("Skip ALL verification (UBS, typecheck, tests)"),
    skip_review: tool.schema
      .boolean()
      .optional()
      .describe("Skip review gate check"),
  },
  execute: (args, ctx) => execTool("swarm_complete", args, ctx),
});

const swarm_record_outcome = tool({
  description: "Record subtask outcome for implicit feedback scoring",
  args: {
    bead_id: tool.schema.string().describe("Cell ID"),
    duration_ms: tool.schema.number().int().min(0).describe("Duration in ms"),
    error_count: tool.schema
      .number()
      .int()
      .min(0)
      .optional()
      .describe("Error count"),
    retry_count: tool.schema
      .number()
      .int()
      .min(0)
      .optional()
      .describe("Retry count"),
    success: tool.schema.boolean().describe("Whether task succeeded"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files modified"),
    criteria: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Evaluation criteria"),
    strategy: tool.schema
      .enum(["file-based", "feature-based", "risk-based"])
      .optional()
      .describe("Strategy used"),
  },
  execute: (args, ctx) => execTool("swarm_record_outcome", args, ctx),
});

const swarm_subtask_prompt = tool({
  description: "Generate the prompt for a spawned subtask agent",
  args: {
    agent_name: tool.schema.string().describe("Agent name"),
    bead_id: tool.schema.string().describe("Cell ID"),
    epic_id: tool.schema.string().describe("Epic ID"),
    subtask_title: tool.schema.string().describe("Subtask title"),
    subtask_description: tool.schema
      .string()
      .optional()
      .describe("Description"),
    files: tool.schema.array(tool.schema.string()).describe("Files to work on"),
    shared_context: tool.schema.string().optional().describe("Shared context"),
  },
  execute: (args, ctx) => execTool("swarm_subtask_prompt", args, ctx),
});

const swarm_spawn_subtask = tool({
  description: "Prepare a subtask for spawning with Task tool",
  args: {
    bead_id: tool.schema.string().describe("Cell ID"),
    epic_id: tool.schema.string().describe("Epic ID"),
    subtask_title: tool.schema.string().describe("Subtask title"),
    subtask_description: tool.schema
      .string()
      .optional()
      .describe("Description"),
    files: tool.schema.array(tool.schema.string()).describe("Files to work on"),
    shared_context: tool.schema.string().optional().describe("Shared context"),
  },
  execute: (args, ctx) => execTool("swarm_spawn_subtask", args, ctx),
});

const swarm_complete_subtask = tool({
  description: "Handle subtask completion after Task agent returns",
  args: {
    bead_id: tool.schema.string().describe("Cell ID"),
    task_result: tool.schema.string().describe("Task result JSON"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files modified"),
  },
  execute: (args, ctx) => execTool("swarm_complete_subtask", args, ctx),
});

const swarm_evaluation_prompt = tool({
  description: "Generate self-evaluation prompt for a completed subtask",
  args: {
    bead_id: tool.schema.string().describe("Cell ID"),
    subtask_title: tool.schema.string().describe("Subtask title"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .describe("Files modified"),
  },
  execute: (args, ctx) => execTool("swarm_evaluation_prompt", args, ctx),
});

const swarm_broadcast = tool({
  description:
    "Broadcast context update to all agents working on the same epic",
  args: {
    project_path: tool.schema.string().describe("Project path"),
    agent_name: tool.schema.string().describe("Agent name"),
    epic_id: tool.schema.string().describe("Epic ID"),
    message: tool.schema.string().describe("Context update message"),
    importance: tool.schema
      .enum(["info", "warning", "blocker"])
      .optional()
      .describe("Priority level (default: info)"),
    files_affected: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files this context relates to"),
  },
  execute: (args, ctx) => execTool("swarm_broadcast", args, ctx),
});

// =============================================================================
// Worktree Isolation Tools
// =============================================================================

const swarm_worktree_create = tool({
  description:
    "Create a git worktree for isolated task execution. Worker operates in worktree, not main branch.",
  args: {
    project_path: tool.schema.string().describe("Absolute path to project root"),
    task_id: tool.schema.string().describe("Task/bead ID (e.g., bd-abc123.1)"),
    start_commit: tool.schema
      .string()
      .describe("Commit SHA to create worktree at (swarm start point)"),
  },
  execute: (args, ctx) => execTool("swarm_worktree_create", args, ctx),
});

const swarm_worktree_merge = tool({
  description:
    "Cherry-pick commits from worktree back to main branch. Call after worker completes.",
  args: {
    project_path: tool.schema.string().describe("Absolute path to project root"),
    task_id: tool.schema.string().describe("Task/bead ID"),
    start_commit: tool.schema
      .string()
      .optional()
      .describe("Original start commit (to find new commits)"),
  },
  execute: (args, ctx) => execTool("swarm_worktree_merge", args, ctx),
});

const swarm_worktree_cleanup = tool({
  description:
    "Remove a worktree after completion or abort. Idempotent - safe to call multiple times.",
  args: {
    project_path: tool.schema.string().describe("Absolute path to project root"),
    task_id: tool.schema.string().optional().describe("Task/bead ID to clean up"),
    cleanup_all: tool.schema
      .boolean()
      .optional()
      .describe("Remove all worktrees for this project"),
  },
  execute: (args, ctx) => execTool("swarm_worktree_cleanup", args, ctx),
});

const swarm_worktree_list = tool({
  description: "List all active worktrees for a project",
  args: {
    project_path: tool.schema.string().describe("Absolute path to project root"),
  },
  execute: (args, ctx) => execTool("swarm_worktree_list", args, ctx),
});

// =============================================================================
// Structured Review Tools
// =============================================================================

const swarm_review = tool({
  description:
    "Generate a review prompt for a completed subtask. Includes epic context, dependencies, and diff.",
  args: {
    project_key: tool.schema.string().describe("Project path"),
    epic_id: tool.schema.string().describe("Epic bead ID"),
    task_id: tool.schema.string().describe("Subtask bead ID to review"),
    files_touched: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Files modified (will get diff for these)"),
  },
  execute: (args, ctx) => execTool("swarm_review", args, ctx),
});

const swarm_review_feedback = tool({
  description:
    "Send review feedback to a worker. Tracks attempts (max 3). Fails task after 3 rejections.",
  args: {
    project_key: tool.schema.string().describe("Project path"),
    task_id: tool.schema.string().describe("Subtask bead ID"),
    worker_id: tool.schema.string().describe("Worker agent name"),
    status: tool.schema
      .enum(["approved", "needs_changes"])
      .describe("Review status"),
    summary: tool.schema.string().optional().describe("Review summary"),
    issues: tool.schema
      .string()
      .optional()
      .describe("JSON array of ReviewIssue objects (for needs_changes)"),
  },
  execute: (args, ctx) => execTool("swarm_review_feedback", args, ctx),
});

// =============================================================================
// Skills Tools
// =============================================================================

const skills_list = tool({
  description:
    "List all available skills from global, project, and bundled sources",
  args: {
    source: tool.schema
      .enum(["all", "global", "project", "bundled"])
      .optional()
      .describe("Filter by source (default: all)"),
  },
  execute: (args, ctx) => execTool("skills_list", args, ctx),
});

const skills_read = tool({
  description: "Read a skill's full content including SKILL.md and references",
  args: {
    name: tool.schema.string().describe("Skill name"),
  },
  execute: (args, ctx) => execTool("skills_read", args, ctx),
});

const skills_use = tool({
  description:
    "Get skill content formatted for injection into agent context. Use this when you need to apply a skill's knowledge to the current task.",
  args: {
    name: tool.schema.string().describe("Skill name"),
    context: tool.schema
      .string()
      .optional()
      .describe("Optional context about how the skill will be used"),
  },
  execute: (args, ctx) => execTool("skills_use", args, ctx),
});

const skills_create = tool({
  description: "Create a new skill with SKILL.md template",
  args: {
    name: tool.schema.string().describe("Skill name (kebab-case)"),
    description: tool.schema.string().describe("Brief skill description"),
    scope: tool.schema
      .enum(["global", "project"])
      .optional()
      .describe("Where to create (default: project)"),
    tags: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Skill tags for discovery"),
  },
  execute: (args, ctx) => execTool("skills_create", args, ctx),
});

const skills_update = tool({
  description: "Update an existing skill's SKILL.md content",
  args: {
    name: tool.schema.string().describe("Skill name"),
    content: tool.schema.string().describe("New SKILL.md content"),
  },
  execute: (args, ctx) => execTool("skills_update", args, ctx),
});

const skills_delete = tool({
  description: "Delete a skill (project skills only)",
  args: {
    name: tool.schema.string().describe("Skill name"),
  },
  execute: (args, ctx) => execTool("skills_delete", args, ctx),
});

const skills_init = tool({
  description: "Initialize skills directory in current project",
  args: {
    path: tool.schema
      .string()
      .optional()
      .describe("Custom path (default: .opencode/skills)"),
  },
  execute: (args, ctx) => execTool("skills_init", args, ctx),
});

const skills_add_script = tool({
  description: "Add an executable script to a skill",
  args: {
    skill_name: tool.schema.string().describe("Skill name"),
    script_name: tool.schema.string().describe("Script filename"),
    content: tool.schema.string().describe("Script content"),
    executable: tool.schema
      .boolean()
      .optional()
      .describe("Make executable (default: true)"),
  },
  execute: (args, ctx) => execTool("skills_add_script", args, ctx),
});

const skills_execute = tool({
  description: "Execute a skill's script",
  args: {
    skill_name: tool.schema.string().describe("Skill name"),
    script_name: tool.schema.string().describe("Script to execute"),
    args: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Script arguments"),
  },
  execute: (args, ctx) => execTool("skills_execute", args, ctx),
});

// =============================================================================
// Plugin Export
// =============================================================================

// =============================================================================
// Compaction Hook - Swarm Recovery Context
// =============================================================================

/**
 * Detection result with confidence level
 */
interface SwarmDetection {
  detected: boolean;
  confidence: "high" | "medium" | "low" | "none";
  reasons: string[];
}

/**
 * Check for swarm sign - evidence a swarm passed through
 *
 * Uses multiple signals with different confidence levels:
 * - HIGH: in_progress cells (active work)
 * - MEDIUM: Open subtasks, unclosed epics, recently updated cells
 * - LOW: Any cells exist
 *
 * Philosophy: Err on the side of continuation.
 * False positive = extra context (low cost)
 * False negative = lost swarm (high cost)
 */
async function detectSwarm(): Promise<SwarmDetection> {
  const reasons: string[] = [];
  let highConfidence = false;
  let mediumConfidence = false;
  let lowConfidence = false;

  try {
    const result = await new Promise<{ exitCode: number; stdout: string }>(
      (resolve) => {
        // Use swarm tool to query beads
        const proc = spawn(SWARM_CLI, ["tool", "hive_query"], {
          stdio: ["ignore", "pipe", "pipe"],
        });
        let stdout = "";
        proc.stdout.on("data", (d) => {
          stdout += d;
        });
        proc.on("close", (exitCode) =>
          resolve({ exitCode: exitCode ?? 1, stdout }),
        );
      },
    );

    if (result.exitCode !== 0) {
      return { detected: false, confidence: "none", reasons: ["hive_query failed"] };
    }

    const cells = JSON.parse(result.stdout);
    if (!Array.isArray(cells) || cells.length === 0) {
      return { detected: false, confidence: "none", reasons: ["no cells found"] };
    }

    // HIGH: Any in_progress cells
    const inProgress = cells.filter(
      (c: { status: string }) => c.status === "in_progress"
    );
    if (inProgress.length > 0) {
      highConfidence = true;
      reasons.push(`${inProgress.length} cells in_progress`);
    }

    // MEDIUM: Open subtasks (cells with parent_id)
    const subtasks = cells.filter(
      (c: { status: string; parent_id?: string }) =>
        c.status === "open" && c.parent_id
    );
    if (subtasks.length > 0) {
      mediumConfidence = true;
      reasons.push(`${subtasks.length} open subtasks`);
    }

    // MEDIUM: Unclosed epics
    const openEpics = cells.filter(
      (c: { status: string; type?: string }) =>
        c.type === "epic" && c.status !== "closed"
    );
    if (openEpics.length > 0) {
      mediumConfidence = true;
      reasons.push(`${openEpics.length} unclosed epics`);
    }

    // MEDIUM: Recently updated cells (last hour)
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    const recentCells = cells.filter(
      (c: { updated_at?: number }) => c.updated_at && c.updated_at > oneHourAgo
    );
    if (recentCells.length > 0) {
      mediumConfidence = true;
      reasons.push(`${recentCells.length} cells updated in last hour`);
    }

    // LOW: Any cells exist at all
    if (cells.length > 0) {
      lowConfidence = true;
      reasons.push(`${cells.length} total cells in hive`);
    }
  } catch {
    // Detection failed, use fallback
    lowConfidence = true;
    reasons.push("Detection error, using fallback");
  }

  // Determine overall confidence
  let confidence: "high" | "medium" | "low" | "none";
  if (highConfidence) {
    confidence = "high";
  } else if (mediumConfidence) {
    confidence = "medium";
  } else if (lowConfidence) {
    confidence = "low";
  } else {
    confidence = "none";
  }

  return {
    detected: confidence !== "none",
    confidence,
    reasons,
  };
}

/**
 * Swarm-aware compaction context
 *
 * Injected during compaction to keep the swarm cooking. The coordinator should
 * wake up from compaction and immediately resume orchestration - spawning agents,
 * monitoring progress, unblocking work.
 */
const SWARM_COMPACTION_CONTEXT = `## üêù SWARM ACTIVE - Keep Cooking

You are the **COORDINATOR** of an active swarm. Context was compacted but the swarm is still running.

**YOUR JOB:** Keep orchestrating. Spawn agents. Monitor progress. Unblock work. Ship it.

### Preserve in Summary

Extract from session context:

1. **Epic & Subtasks** - IDs, titles, status, file assignments
2. **What's Running** - Which agents are active, what they're working on  
3. **What's Blocked** - Blockers and what's needed to unblock
4. **What's Done** - Completed work and any follow-ups needed
5. **What's Next** - Pending subtasks ready to spawn

### Summary Format

\`\`\`
## üêù Swarm State

**Epic:** <bd-xxx> - <title>
**Project:** <path>
**Progress:** X/Y subtasks complete

**Active:**
- <bd-xxx>: <title> [in_progress] ‚Üí <agent> working on <files>

**Blocked:**
- <bd-xxx>: <title> - BLOCKED: <reason>

**Completed:**
- <bd-xxx>: <title> ‚úì

**Ready to Spawn:**
- <bd-xxx>: <title> (files: <...>)
\`\`\`

### On Resume - IMMEDIATELY

1. \`swarm_status(epic_id="<epic>", project_key="<path>")\` - Get current state
2. \`swarmmail_inbox(limit=5)\` - Check for agent messages
3. \`swarm_review(project_key, epic_id, task_id, files_touched)\` - Review any completed work
4. \`swarm_review_feedback(project_key, task_id, worker_id, status, issues)\` - Approve or request changes
5. **Spawn ready subtasks** - Don't wait, fire them off
6. **Unblock blocked work** - Resolve dependencies, reassign if needed
7. **Collect completed work** - Close done subtasks, verify quality

### Keep the Swarm Cooking

- **Spawn aggressively** - If a subtask is ready and unblocked, spawn an agent
- **Monitor actively** - Check status, read messages, respond to blockers
- **Close the loop** - When all subtasks done, verify and close the epic
- **Don't stop** - The swarm runs until the epic is closed

**You are not waiting for instructions. You are the coordinator. Coordinate.**
`;

/**
 * Fallback detection prompt - tells the compactor what to look for
 * 
 * Used when we can't definitively detect a swarm but want to be safe.
 * The compactor can check the conversation context for these patterns.
 */
const SWARM_DETECTION_FALLBACK = `## üêù Swarm Detection - Check Your Context

**IMPORTANT:** Before summarizing, check if this session involves an active swarm.

Look for ANY of these patterns in the conversation:

### Tool Calls (definite swarm sign)
- \`swarm_decompose\`, \`swarm_spawn_subtask\`, \`swarm_status\`, \`swarm_complete\`
- \`swarmmail_init\`, \`swarmmail_reserve\`, \`swarmmail_send\`
- \`hive_create_epic\`, \`hive_start\`, \`hive_close\`

### IDs and Names
- Cell IDs: \`bd-xxx\`, \`bd-xxx.N\` (subtask format)
- Agent names: BlueLake, RedMountain, GreenValley, etc.
- Epic references: "epic", "subtask", "parent"

### Coordination Language
- "spawn", "worker", "coordinator"
- "reserve", "reservation", "files"
- "blocked", "unblock", "dependency"
- "progress", "complete", "in_progress"

### If You Find Swarm Evidence

Include this in your summary:
1. Epic ID and title
2. Project path
3. Subtask status (running/blocked/done/pending)
4. Any blockers or issues
5. What should happen next

**Then tell the resumed session:**
"This is an active swarm. Check swarm_status and swarmmail_inbox immediately."
`;

// Extended hooks type to include experimental compaction hook
type ExtendedHooks = Hooks & {
  "experimental.session.compacting"?: (
    input: { sessionID: string },
    output: { context: string[] },
  ) => Promise<void>;
};

export const SwarmPlugin: Plugin = async (
  input: PluginInput,
): Promise<ExtendedHooks> => {
  // CRITICAL: Set project directory from OpenCode input
  // Without this, CLI uses wrong database path
  projectDirectory = input.directory;
  
  return {
    tool: {
      // Beads
      hive_create,
      hive_create_epic,
      hive_query,
      hive_update,
      hive_close,
      hive_start,
      hive_ready,
      hive_sync,
      beads_link_thread,
      // Swarm Mail (Embedded)
      swarmmail_init,
      swarmmail_send,
      swarmmail_inbox,
      swarmmail_read_message,
      swarmmail_reserve,
      swarmmail_release,
      swarmmail_ack,
      swarmmail_health,
      // Structured
      structured_extract_json,
      structured_validate,
      structured_parse_evaluation,
      structured_parse_decomposition,
      structured_parse_cell_tree,
      // Swarm
      swarm_init,
      swarm_select_strategy,
      swarm_plan_prompt,
      swarm_decompose,
      swarm_validate_decomposition,
      swarm_status,
      swarm_progress,
      swarm_complete,
      swarm_record_outcome,
      swarm_subtask_prompt,
      swarm_spawn_subtask,
      swarm_complete_subtask,
      swarm_evaluation_prompt,
      swarm_broadcast,
      // Worktree Isolation
      swarm_worktree_create,
      swarm_worktree_merge,
      swarm_worktree_cleanup,
      swarm_worktree_list,
      // Structured Review
      swarm_review,
      swarm_review_feedback,
      // Skills
      skills_list,
      skills_read,
      skills_use,
      skills_create,
      skills_update,
      skills_delete,
      skills_init,
      skills_add_script,
      skills_execute,
    },

    // Swarm-aware compaction hook - injects context based on detection confidence
    "experimental.session.compacting": async (
      _input: { sessionID: string },
      output: { context: string[] },
    ) => {
      const detection = await detectSwarm();

      if (detection.confidence === "high" || detection.confidence === "medium") {
        // Definite or probable swarm - inject full context
        const header = `[Swarm detected: ${detection.reasons.join(", ")}]\n\n`;
        output.context.push(header + SWARM_COMPACTION_CONTEXT);
      } else if (detection.confidence === "low") {
        // Possible swarm - inject fallback detection prompt
        const header = `[Possible swarm: ${detection.reasons.join(", ")}]\n\n`;
        output.context.push(header + SWARM_DETECTION_FALLBACK);
      }
      // confidence === "none" - no injection, probably not a swarm
    },
  };
};

export default SwarmPlugin;
